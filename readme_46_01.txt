Документация
============

Задача: LR метод поиска собственных значений для матриц общего вида, приведение к почти треугольному виду унитарным подобием методом отражений.
--------------------------------------------------------------------------

Выполнил: Солиев Музаффар / Группа: М1-15
-------------------------------------------

==================
запуск программы:

evc [input_file_name] [output_file_name] [options]
Where options include:
  -d    print debug messages [default OFF]
  -e    print errors [default OFF]
  -p    print matrix [default OFF]
  -t    print execution time [default OFF]
  -prec=<num>       precision [default - 1e-14]  
  -eps=<num>        'epsilon' [default - 1e-10]
  -max_iter=<num>   limit number of iterations 
                    [default - 0, i.e. not limit]
  -h, -?     print this and exit

Входные данные:
n
а11 а12 ... а1n
...............
an1 an2 ... ann

размерность матрицы и матрица соответсвенно


Выходные данные :
если задача имеет решение с данными алгоритмами:
n
е1
е2
...
еn
если нет, то печатаеся 0.
  
По умолчанию входной/выходной файл:
46_01_in.txt
46_01_out.txt
==================
error - флаг ошибок
debug - флаг отладки

Коды ошибки
	 0 - ошибок нет.
	-1 - входной файл не открыт.
	-2 - файл пуст либо количество уравений меньше нуля.
	-3 - не удалось выделить память.
	-4 - не удалось считать элемент матрицы.
	-5 - метод не сходится за указанное число итераций.


______________________________________
size_t stringLength(const char *str)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
const char *str - указатель на строку
- функция возвращает количество символов в строке str.
Перебирает все символы, пока не встретится символ('\0') и увеличивает
счётчик. Когда встречается первый нулевой символ возвращает значение счётчика.

_______________________________________________________
int stringComp(const char *str1, const char *str2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
const char *str1 - указатель на первую строку
const char *str2 - указатель на вторую строку
- функция посимвольно сравнивает две строки (str1 и str2) и выдает:
	-1 - когда длины двух строк разные или эти строри разные
	 1 - когда две строки совпадают
_______________________________________________________
int NstringComp(const char *str1, const char *str2, int n)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
const char *str1 - указатель на первую строку
const char *str2 - указатель на вторую строку
n - длина подстроки которое нужно сравнить
- функция посимвольно сравнивает две строки (str1 и str2) и выдает:
	0 - когда длины двух строк разные или эти строки разные
	1 - когда две строки совпадают
____________________________________________________________________________________
void multiplicationMatrix(double *A, double *B, int n, double *AB, double precision)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
n - размерность матриц
*A - указаель на первую матрицу
*B - указатель на вторую матрицу
*AB - указатель на матрицу в которую будут записываться произвеление матриц A и B.
precision - это такое число, что все числа меньше precision равны нулю.
--------------------------------------------------------------------------
- процедура умножает матрицу A на матрицу B и записывте значение в матрицу AB

______________________________
void print(double *A, int n)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
n - размерность матриц
*A - указаель матрицу
------------------------------
- процедура печатает матрицу A

__________________________________________________________________________
int sim_46_01(int n, double* A, double* tmp, double precision)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
n - размерность матриц
*A - указатель на массив элементов матрицы (одномерный массив.
матрица задана как последовательность а<0,0> а<0,1> ... а<0,n> .... a<n,n>)
*tmp - указатель на массив дополнительной памяти
precision - это такое число, что все числа меньше precision равны нулю.
--------------------------------------------------------------------------------------------------
- функция приводит исходную матрицу к пости треугольному виду унитарным подобием методом отражений и выдаёт:
	0 - когда матрица приведена к почти трецголному виду.

_________________________________________
size_t sim_memsize_46_01(int n)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
n - размерность матриц
-----------------------------------------
- функция выделяет дополнительную память.

____________________________________________________________
void bubbleSort(double* ArrayPtr, int length_array)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
* ArrayPtr = указатель на массив который нужно отсортировать
length_array - размерность массива
------------------------------------------------------------
 - процедура сортирует массив пузырьковой сортировкой.

________________________________________________________
double normalInfinit(double *A, int n, double precision)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
n - размерность матрицы
* A - указатель на массив элементов матрицы
precision - это такое число, что все числа меньше precision равны нулю.
-----------------------------------------------------------------------
 - функция вычисляет максимальную строчную норму


_____________________________________________________________________________________________________________
int evc_46_01(int n, int max_iterations, double epsilon, double* A, double* E, double* tmp, double precision)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
n - размерность матрицы
max_iterations - количество максимальных итераций
epsilon - точность
* A - указатель на массив элементов матрицы
* E - указатель на массив собственных значений
* tmp - указатель на массив дополнительной памяти
precision - это такое число, что все числа меньше precision равны нулю.
-------------------------------------------------------------------------------------------------------------
 - функция находит собственные значения для матицы методом LR разложения и выдаёт:
	0 - когда находит собственные значаения за указанное число итераций
	1 - когда функция не сходится за указанное число итераций.


Алгоритм:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Приведение к почти треугольному виду:
1.1 Берём все элементы первого столбца которые лежат под главной диагонялью матрицы. Считаем для них норму.
1.2 Сторим матрицу Ux. По формуле(стр.71 Богачёв) нахождения x(1) и по формуле (4) стороим матрицу U(вектор x(i) умножаем на x(i)* ещё умножаем на два и полученные результата отнимаем от единичной матрицы). На диагонатьном элементе матрицы Ux записывамем единицу, первую строку и первый столбец заполняем нулями, а на оставшемся место дописываем матрицу U.
1.3 Нашу исходную матрицу А умножаем слева и справа на Ux.
Повторяем 1.1 - 1.3 шаги (n-1) раз и получим почти треугольний вид.

2. Нахождение собственных значений матрицы.
2.1 Строим LR разложение для почти треугольной матрицы по формуле (4 - стр 100 Богачёв)
2.2 Вычисляем произведение матриц L и R и записываем в матрицу А.
2.3 Повторяем шаги 2.1 - 2.2 указанное число раз.
Собственные значения дял больших матриц не будут сходиться с указанной точность.
Поэтому будем использовать сдвиги.
2.1 Определяем сдвиг sk = A[n][n]
2.2 Для почти треугольной матрицы А применямем LR-алгоритм со сдвигами.
Как только на нектором шаге k будет выполнятся |A[n][n-1]| < epsilon*normalInfinity. В качестве E[n] возьмём A[n][n]. B применяем алгоритм для подматрицы А с размерностью (n-1)x(n-1).
Так поступаем пока размерность матрицы не станет 2 x 2. Для такой матрицы собственные значениями будут решение квадратного уравнения. 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

По умолчанию:
precision = 1e-14
epsilon = 1e-10,



